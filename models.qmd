---
title: "STAT 455 Project"
format: html
editor: source
execute:
  echo: true
  warning: false
  message: false
  seed: 17
---

## Read/inspect data

Source: https://www.eia.gov/dnav/ng/ng_enr_drill_s1_m.htm

```{r}
library(ggplot2)
library(forecast)
library(zoo)
library(acp)
library(tscount)



data <- read.csv('data/rigs.csv')

data$date <- as.Date(paste0("01-", data$date), format = "%d-%b-%y")

data %>% 
  ggplot(aes(date, count)) + 
  geom_line() + 
  theme_minimal() + 
  labs(x = 'Date',
       y = 'Count',
       title = 'US Oil Rig Count by Date')
```

## Convert data to time series

```{r}
data$date <- as.yearmon(data$date, "%b-%y")

z <- ts(data$count, 
        start = c(as.numeric(format(data$date[1], "%Y")), 
                  as.numeric(format(data$date[1], "%m"))),
        frequency = 12)
```


## Helper function to evaluate a fitted model

```{r}
evaluate <- function(actual, forecasted, dates){
  print(accuracy(forecasted, actual))
  
  results <- data.frame(date = rep(dates, 2),
                      value = c(actual, forecasted),
                      type = c(rep('Actual', length(actual)),
                               rep('Forecasted', length(forecasted))))
  
  results %>% 
    ggplot(aes(x = date,
               y = value,
               color = type)) + 
    geom_line() + 
    theme_minimal() + 
    labs(x = 'Date',
         y = 'Count',
         title = 'US Oil Rig Count by Date') +
    theme(legend.title = element_blank())
}
```

## Fit/evaluate ARIMA

```{r}
# use a 5-year test window
test_years <- 5
test_horizon <- test_years * 12

n <- length(z)
start_test <- n - test_horizon
h <- 1 # 1-step forecast

pred <- rep(NA, n)

# rolling window forecast
for (i in start_test:(n - h)) {
  # train on everything before forecast origin
  train <- window(z, end = time(z)[i])
  
  # fit ARIMA
  fit <- auto.arima(train)
  
  # 1-step ahead forecast
  pred[i + h] <- forecast(fit, h = h)$mean[h]
}

# actual/predicted for test window
idx <- start_test + h
actual <- z[idx:n]
forecasted <- pred[idx:n]

dates <- index(z)[idx:n]

evaluate(actual, forecasted, dates)
```


## Fit ACP models

### ACP using acp library

```{r}
library(acp)
pred_acp <- rep(NA, n)

# rolling window forcast
for (i in start_test:(n - h)) {
  
  # train on everything before forecast origin
  train <- window(z, end = time(z)[i])
  fit_acp <- suppressWarnings(acp(train ~ -1, p = 1, q = 1))


  # extract last values
  y_last <- tail(train, 1)
  # print(y_last)

  #last_lambda <- tail(fit_acp$fitted.values, 1)
  lambda_last <- fit_acp$fitted.values[length(fit_acp$fitted.values)]
  # print(lambda_last)

  # λ̂_{t+1} = α y_t + β λ_t + ω
  # extract parameter estimates and use to predict next count
  par <- coef(fit_acp)
  omega <- par[1]
  alpha <- par[2]
  beta  <- par[3]
  # print(par)

  
  lambda_next <- omega + alpha * y_last + beta * lambda_last
  # print(lambda_next)
  pred_acp[i + h] <- lambda_next

}

# actual/predicted for test window
idx <- start_test + h
actual <- z[idx:n]
forecasted_acp <- pred_acp[idx:n]
dates <- index(z)[idx:n]

evaluate(actual, forecasted_acp, dates)

```
### ACP using tscount library

```{r}
library(tscount)

pred_acp <- rep(NA, n)
h <- 1

for (i in start_test:(n - h)) {

  train <- window(z, end = time(z)[i])
  
  fit <- suppressWarnings(tsglm(train, model = list(past_obs = 1, past_mean = 1),link = "identity", distr = "poisson"))
  
  lambda_next <- predict(fit, n.ahead = h)$pred[h]
  pred_acp[i + h] <- lambda_next}

idx <- start_test + h
actual <- z[idx:n]
forecasted_acp <- pred_acp[idx:n]
dates <- index(z)[idx:n]

evaluate(actual, forecasted_acp, dates)

```







